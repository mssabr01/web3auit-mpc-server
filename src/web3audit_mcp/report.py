"""Structured Markdown report generator."""

from __future__ import annotations

from datetime import datetime, timezone
from textwrap import indent

from .models import AuditResult, Finding, Severity

_SEVERITY_BADGE: dict[Severity, str] = {
    Severity.CRITICAL: "ðŸ”´ CRITICAL",
    Severity.HIGH: "ðŸŸ  HIGH",
    Severity.MEDIUM: "ðŸŸ¡ MEDIUM",
    Severity.LOW: "ðŸ”µ LOW",
    Severity.INFORMATIONAL: "âšª INFO",
}


def _finding_block(f: Finding, idx: int) -> str:
    lines: list[str] = []
    badge = _SEVERITY_BADGE[f.severity]
    lines.append(f"### {badge} â€” {f.title}")
    lines.append("")
    lines.append(f"| Field | Value |")
    lines.append(f"|-------|-------|")
    lines.append(f"| **ID** | `{f.id}` |")
    lines.append(f"| **Detector** | `{f.detector}` |")
    lines.append(f"| **Severity** | {f.severity.value} |")
    lines.append(f"| **Confidence** | {f.confidence.value} |")
    lines.append(f"| **Source** | {f.source_tool.value} |")
    lines.append("")

    if f.locations:
        lines.append("**Locations:**")
        lines.append("")
        for loc in f.locations:
            loc_str = f"`{loc.file}`"
            if loc.contract:
                loc_str += f" â†’ `{loc.contract}`"
            if loc.function:
                loc_str += f" â†’ `{loc.function}()`"
            if loc.line_start:
                loc_str += f"  (L{loc.line_start}"
                if loc.line_end and loc.line_end != loc.line_start:
                    loc_str += f"â€“{loc.line_end}"
                loc_str += ")"
            lines.append(f"- {loc_str}")
        lines.append("")

    if f.description:
        lines.append("**Description:**")
        lines.append("")
        lines.append(f.description)
        lines.append("")

    if f.recommendation:
        lines.append("**Recommendation:**")
        lines.append("")
        lines.append(f.recommendation)
        lines.append("")

    if f.references:
        lines.append("**References:**")
        lines.append("")
        for ref in f.references:
            lines.append(f"- <{ref}>")
        lines.append("")

    lines.append("---")
    lines.append("")
    return "\n".join(lines)


def generate_report(result: AuditResult) -> str:
    """Produce a full Markdown audit report from an AuditResult."""
    counts = result.summary_counts
    total = sum(counts.values())

    parts: list[str] = []

    # Header
    parts.append("# Smart Contract Audit Report")
    parts.append("")
    parts.append(f"**Project:** `{result.project_path}`")
    parts.append(f"**Date:** {result.timestamp}")
    parts.append(f"**Tools:** {', '.join(result.tools_ran)}")
    parts.append("")

    # Executive summary
    parts.append("## Executive Summary")
    parts.append("")
    parts.append(
        f"The automated audit found **{total} unique findings** "
        f"({result.dedup_removed} duplicates removed across tools)."
    )
    parts.append("")
    parts.append("| Severity | Count |")
    parts.append("|----------|------:|")
    for sev in Severity:
        badge = _SEVERITY_BADGE[sev]
        parts.append(f"| {badge} | {counts.get(sev.value, 0)} |")
    parts.append("")

    if result.errors:
        parts.append("### Errors During Analysis")
        parts.append("")
        for err in result.errors:
            parts.append(f"- {err}")
        parts.append("")

    # Findings by severity
    for sev in Severity:
        group = result.by_severity[sev]
        if not group:
            continue
        parts.append(f"## {_SEVERITY_BADGE[sev]} Findings ({len(group)})")
        parts.append("")
        for idx, f in enumerate(group, 1):
            parts.append(_finding_block(f, idx))

    # Footer
    parts.append("---")
    parts.append("")
    parts.append(
        "*Generated by web3audit-mcp. "
        "This is an automated report â€” manual review is strongly recommended.*"
    )

    return "\n".join(parts)
